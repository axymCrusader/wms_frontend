## Компонентная архитектура проекта

Структура позаимствована частично из архитектуры Feature-Sliced Design

Полностью ее реализовать на Nuxt нет возможности, из за строгой архитектуры директорий в Nuxt. Но ниже описанный подход, дает отличный результат компоновки приложений.

Папка components содержит в себе разделы

- Shared - многоразовый функционал, оторванный от специфики проекта/бизнеса. (например компоненты: кнопки, иконки, бары для страниц или служебные компоненты общего назначения)

- Entities - хозяйствующие субъекты. (например компоненты: таблица с пользователями, бар для страницы с пользователями)

- Features - взаимодействия с пользователем, действия, которые приносят пользователю бизнес-ценность. (например компоненты: модальное окно создания пользователя, поиск, фильтр)

- Widgets - композиционный слой для объединения сущностей и признаков в значимые блоки. (например: страница пользователей со списком пользователей, писком, кнопкой добавить пользователя)

- Pages - данный пункт из оригинальной доки в Nuxt заменяет директория Pages.

В папке pages находятся все наши страницы приложения, при этом в сам файл страницы вписывается только один компонент из Widgets.

page может содержать мета данные для различных нужд (например: права доступа на страницу, описание, заголовок и т.д.)

## Работа с Style TypeScript

#### Расположение типов

Все типы должны располагаться в по пути **/utils/types**

Файлы с типами .ts следует разбивать на логические блоки.
**\*Пример**: все типы для Store Pinia хранятся в папке **/utils/types/store\***
Именование файла состоит из **название логического блока + Types.ts**
**\*Пример**: commonStore.ts\*

#### Именования сущностей

Именования type, interface, map и enum следует производить следующим образом:

| Style          | Category                                                 |
| -------------- | -------------------------------------------------------- |
| UpperCamelCase | class / interface / type / enum / decorator / parameters |
| lowerCamelCase | variable / function / method / property / module alias   |
| CONSTANT_CASE  | global constant values                                   |

</br>

- Не использовать дополнительные именования интерфейсов и типов</br>
  **Плохо**: IMyEnyStore, TButtomType
  **Хорошо**: MyEnyStore, ButtomType
  Дайте имя интерфейсу/типу и т.д., которое в первую очередь почему интерфейс/ тип существует.
  </br>
- Описание имен</br>
  Имена должны быть описательными и понятными новому читателю. Не используйте сокращения, которые являются двусмысленными или незнакомыми читателям за пределами вашего проекта, а также не сокращайте, удаляя буквы внутри слова.</br>
  Исключение : переменные, длина которых составляет 10 или менее строк, включая аргументы, которые не являются частью экспортированного API, могут использовать короткие (например, однобуквенные) имена переменных.
  </br>
- Если интерфейс имеет наследников, то базовый интерфейс следует называть по типу: MyObjectBase
- Если тебе требуется создать потомка без определенного поля, то называть необходимо следующим образом: MyObjectBaseWithOutId, аналогично в обратном порядке MyObjectBaseWithAnyAttribute

## Работа со Store Pinia

#### Разделение сущностей

Нельзя всё хранить в одном store, и нельзя хранить все stores в одном файле!
Разделяй stores по сущностям и записывай их по разным файлам.

#### Именование файлов Store

Название логического блока + Store.ts

#### Расположение файлов хранилища

Все файлы располагаются в директории /stores

#### Описание файлов Store

- **Именование store**
  Глобальное имя должно быть всегда use + название логического блока + Store, как указано в примере выше в строке 2.
  В defuneStore передаем без префикса use
  </br>
- **Именование getters**
  Геттеры всегда начинаются с префикса get
  Название после должно отражать возвращаемую сущность/объект/примитив
  </br>
- **Именование actions**
  Actions должны содержать в имени глагол описывающий действие (например: set, get, update, delete, cleare ,toggle и т.д.)
  Actions, которые получают данные с Бека принято оканчивать постфиксом API (например: getUserListFromAPI, setUserToAPI, updateUserToAPI)
